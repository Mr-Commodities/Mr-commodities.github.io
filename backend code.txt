const functions = require("firebase-functions");
const admin = require("firebase-admin");
const cors = require("cors")({ origin: true });
const https = require("https");

admin.initializeApp();
const db = admin.firestore();
const rtdb = admin.database();

const STACKHOUSE_WALLET = "ltc1qxn8j9emw65cpa7kn98frgyrzf3ud5vumw26z7x";

// üîß Modular helper to calculate expected USD amount
function getExpectedUSD(baseEntryFee, rowNum) {
  return baseEntryFee + parseInt(rowNum) * 0.01;
}

// üí∞ Get LTC price using built-in https module
function getLTCPrice() {
  return new Promise((resolve) => {
    const options = {
      hostname: 'api.coingecko.com',
      path: '/api/v3/simple/price?ids=litecoin&vs_currencies=usd',
      method: 'GET',
      headers: {
        'User-Agent': 'Mozilla/5.0'
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => data += chunk);
      res.on('end', () => {
        try {
          const parsed = JSON.parse(data);
          resolve(parsed?.litecoin?.usd || 88);
        } catch (err) {
          console.log('‚ö†Ô∏è Price parse failed, using fallback');
          resolve(88);
        }
      });
    });

    req.on('error', () => {
      console.log('‚ö†Ô∏è Price fetch failed, using fallback');
      resolve(88);
    });

    req.setTimeout(5000, () => {
      console.log('‚ö†Ô∏è Price request timeout, using fallback');
      resolve(88);
    });

    req.end();
  });
}

exports.onIncomingPayment = functions.https.onRequest((req, res) => {
  cors(req, res, async () => {
    try {
      console.log('üéØ Webhook received:', JSON.stringify(req.body, null, 2));
      
      if (req.method !== "POST") {
        return res.status(405).send("Method Not Allowed");
      }

      // ‚úÖ Respond to BlockCypher immediately
      res.status(200).send("‚úÖ Webhook received");

      const { hash: txId, confirmed, outputs } = req.body;
      if (!txId || !confirmed || !outputs) {
        console.log("‚ùå Incomplete transaction payload");
        return;
      }

      const confirmedAt = new Date(confirmed).getTime();
      console.log(`üéØ Processing TX ‚Üí ${txId} @ ${confirmedAt}`);

      // üîç Extract amount sent to Stackhouse wallet
      let amountToWallet = 0;
      let isOurWallet = false;

      for (const output of outputs) {
        if (output.addresses && output.addresses.includes(STACKHOUSE_WALLET)) {
          amountToWallet = output.value / 100000000; // Convert satoshis to LTC
          isOurWallet = true;
          console.log(`üí∞ Amount sent to our wallet: ${amountToWallet} LTC`);
          break;
        }
      }

      if (!isOurWallet || amountToWallet === 0) {
        console.log("‚õî No payment found for our wallet");
        return;
      }

      // üí∏ Get current LTC price
      const ltcPrice = await getLTCPrice();
      console.log(`üí∏ Current LTC Price: $${ltcPrice}`);

      const amountUSD = amountToWallet * ltcPrice;
      console.log(`üíµ Payment amount: ${amountToWallet} LTC = $${amountUSD.toFixed(2)} USD`);

      // üõ°Ô∏è Prevent duplicate transactions
      const txRef = db.collection("usedTxIds").doc(txId);
      const txDoc = await txRef.get();
      if (txDoc.exists) {
        console.log(`‚ö†Ô∏è TX ${txId} already processed`);
        return;
      }

      // üß† Pull active game rows
      const rowsSnapshot = await rtdb.ref("gameRows").once("value");
      const gameRows = rowsSnapshot.val() || {};

      console.log(`üîç Checking against ${Object.keys(gameRows).length} rows`);

      const settingsSnapshot = await rtdb.ref("globalSettings").once("value");
      const settings = settingsSnapshot.val() || {};
      const baseEntryFee = settings.donationAmount || 1;

      console.log(`üí∞ Current base entry fee: $${baseEntryFee.toFixed(2)}`);

      const now = Date.now();
      const pendingRows = Object.entries(gameRows).filter(([_, row]) => {
        return row.status === "pending" &&
               row.claimedAt &&
               row.expiresAt > now;
      });

      console.log(`üéØ Found ${pendingRows.length} pending rows to check`);

      if (pendingRows.length === 0) {
        console.log("üì≠ No pending rows to match");
        return;
      }

      let bestRowNum = null;
      let bestRow = null;
      let smallestDiff = Infinity;

      for (const [rowNum, row] of pendingRows) {
        const expectedUSD = getExpectedUSD(baseEntryFee, rowNum);
        const timeDiff = Math.abs(confirmedAt - (row.claimedAt || row.claimTimestamp));
        const amountDiff = Math.abs(amountUSD - expectedUSD);

        console.log(`üîç Row ${rowNum}: Expected $${expectedUSD.toFixed(2)} | Received $${amountUSD.toFixed(2)} | Diff: $${amountDiff.toFixed(2)} | Time: ${Math.round(timeDiff/1000)}s`);

        const timeMatch = timeDiff <= 20 * 60 * 1000; // 20 minutes tolerance
        const amountMatch = amountDiff <= 0.50; // $0.50 tolerance

        if (timeMatch && amountMatch && amountDiff < smallestDiff) {
          bestRowNum = rowNum;
          bestRow = row;
          smallestDiff = amountDiff;
          console.log(`üéØ NEW BEST MATCH: Row ${rowNum} with diff $${amountDiff.toFixed(2)}`);
        }
      }

      if (!bestRow || !bestRowNum) {
        console.log(`üîç No suitable row match found for TX: ${txId}`);
        console.log(`üí∞ Payment amount: $${amountUSD.toFixed(2)} didn't match any pending rows within $0.50 tolerance`);
        return;
      }

      console.log(`‚úÖ Best match: Row ${bestRowNum} (diff: $${smallestDiff.toFixed(2)})`);

      // ‚úÖ Mark as confirmed
      const rowUpdates = {
        status: "confirmed",
        confirmedAt: Date.now(),
        transactionHash: txId,
        actualAmountPaid: amountUSD,
        actualLTCPaid: amountToWallet,
        confirmedViaWebhook: true,
        preventAutoExpire: true
      };

      await rtdb.ref(`gameRows/${bestRowNum}`).update(rowUpdates);

      // üóÇ Log the transaction
      await txRef.set({
        used: true,
        timestamp: Date.now(),
        assignedToRow: bestRowNum,
        amountLTC: amountToWallet,
        amountUSD: amountUSD,
        confirmedAt
      });

      console.log(`üéâ Row ${bestRowNum} confirmed via webhook! TXID: ${txId} | Amount: $${amountUSD.toFixed(2)}`);

    } catch (error) {
      console.error('‚ùå Webhook processing error:', error);
      // Don't throw error - we already responded to BlockCypher
    }
  });
});

// Health check endpoint for testing
exports.webhookHealth = functions.https.onRequest((req, res) => {
  cors(req, res, () => {
    res.status(200).json({
      status: "healthy",
      timestamp: Date.now(),
      wallet: STACKHOUSE_WALLET
    });
  });
});
